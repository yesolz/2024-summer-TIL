# 리액트 렌더링

브라우저에서 렌더링: HTML과 CSS 리소스 기반으로 웹페이지에 필요한 UI를 그리는 과정.

리액트의 렌더링: 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정.

## 리액트의 렌더링

리액트에서의 렌더링은 리액트 애플리케이션 트리 안의 모든 컴포넌트들이 자신이 가진 props와 state를 기반으로 UI를 구성하고, 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할지 계산하는 과정이다.

- props와 state가 없는 컴포넌트는 반환하는 JSX 값에 기반해 렌더링된다.

## 리액트의 렌더링이 일어나는 이유

렌더링이 언제 발생하는지 이해하는 것이 중요하다.

1. **최초 렌더링**: 사용자가 애플리케이션에 처음 진입할 때.
2. **리렌더링**: 최초 렌더링 이후 모든 렌더링.
   - 클래스형 컴포넌트의 `setState`가 실행될 때
   - 클래스형 컴포넌트의 `forceUpdate`가 실행될 때
   - 함수형 컴포넌트의 `useState`의 setter가 실행될 때
   - 함수형 컴포넌트의 `useReducer`의 dispatch가 실행될 때
   - 컴포넌트의 key props가 변경될 때
   - props가 변경될 때
   - 부모 컴포넌트가 렌더링될 때

이 시나리오에 해당되지 않는 경우, 단순한 변수의 변경은 리렌더링을 발생시키지 않는다.

### 상태 관리 라이브러리와 리렌더링

- MobX와 Redux는 상태 관리를 해주지만 리렌더링을 발생시키지 않는다.
- `mobx-react`, `react-redux`는 상태 변경을 감지해 리렌더링을 발생시킴.
- Recoil 같은 라이브러리는 내부에서 `useState` 등을 통해 리렌더링을 발생시킴.

## 리액트의 렌더링 프로세스

렌더링이 시작되면 리액트는 루트에서부터 업데이트가 필요한 모든 컴포넌트를 찾음.

- 클래스형 컴포넌트: `render()` 함수를 실행
- 함수형 컴포넌트: `FunctionComponent()`를 호출

렌더링 결과물은 JSX 문법으로 구성되며, 이는 `React.createElement()`로 변환됨.

```tsx
function Hello() {
  return (
    <TestComponent a={35} b="yceffort">
      안녕하세요
    </TestComponent>
  );
}
```

위 JSX는 다음과 같이 변환됨:

```tsx
function Hello() {
  return React.createElement(
    TestComponent,
    { a: 35, b: "yceffort" },
    "안녕하세요"
  );
}
```

결과물:

```tsx
{type: TestComponent, props: {a: 35, b: "yceffort", children:"안녕하세요"}}
```

이 과정에서 리액트는 가상 DOM과 비교해 실제 DOM에 반영할 변경 사항을 수집함. 이 과정을 **Reconciliation**이라 함. 변경 사항은 하나의 동기 시퀀스로 DOM에 저장됨.

## 렌더와 커밋

리액트의 렌더링은 **렌더 단계**와 **커밋 단계**로 나뉜다.

### 렌더 단계 (Render Phase)

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 작업.
- 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교해 변경이 필요한 컴포넌트를 체크.

### 커밋 단계 (Commit Phase)

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여줌.
- 이 단계가 끝나야 브라우저 렌더링이 발생함.
- DOM 노드 및 인스턴스를 업데이트하고, 클래스형 컴포넌트의 `componentDidMount`, `componentDidUpdate` 메서드를 호출하며, 함수형 컴포넌트에서는 `useLayoutEffect` 훅을 호출함.

중요한 점은 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것. 변경 사항이 감지되지 않으면 커밋 단계는 생략될 수 있음.

## 리액트 렌더링: 동기 vs. 비동기

전통적으로 리액트의 렌더링은 동기식으로 작동했음. 그러나 렌더링이 길어질수록 애플리케이션의 성능 저하로 이어질 수 있음.

### 동시성 렌더링

리액트 18에서 도입된 **동시성 렌더링**은 렌더링 중 렌더 단계를 비동기로 작동하게 함. 이를 통해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라서는 포기할 수 있음. 이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 트리를 준비할 수 있음.

## 일반적인 렌더링 시나리오

상위 컴포넌트에서 렌더링을 발생시키는 작업이 일어나면 하위 모든 컴포넌트의 리렌더링을 트리거함.

### `React.memo`

`memo`로 래핑된 컴포넌트는 props가 변경되지 않으면 렌더링이 생략됨.

```tsx
import React, { memo } from "react";

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  );
}

const D = memo(() => {
  return <>리액트 재밌다!</>;
});
```

`memo`로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되고 커밋 단계도 생략됨.

`React.memo`는 함수형 컴포넌트의 불필요한 재렌더링을 방지해 성능을 최적화함. 기본적으로 컴포넌트의 props를 얕은 비교(shallow comparison)해 props가 변경되지 않았으면 이전에 렌더링된 결과를 재사용함.
